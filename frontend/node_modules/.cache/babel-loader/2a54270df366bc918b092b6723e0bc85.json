{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.translateAddress = exports.validateAccounts = exports.toInstruction = exports.parseIdlErrors = void 0;\n\nconst web3_js_1 = require(\"@solana/web3.js\");\n\nfunction parseIdlErrors(idl) {\n  const errors = new Map();\n\n  if (idl.errors) {\n    idl.errors.forEach(e => {\n      var _a;\n\n      let msg = (_a = e.msg) !== null && _a !== void 0 ? _a : e.name;\n      errors.set(e.code, msg);\n    });\n  }\n\n  return errors;\n}\n\nexports.parseIdlErrors = parseIdlErrors; // Allow either IdLInstruction or IdlStateMethod since the types share fields.\n\nfunction toInstruction(idlIx) {\n  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    args[_key - 1] = arguments[_key];\n  }\n\n  if (idlIx.args.length != args.length) {\n    throw new Error(\"Invalid argument length\");\n  }\n\n  const ix = {};\n  let idx = 0;\n  idlIx.args.forEach(ixArg => {\n    ix[ixArg.name] = args[idx];\n    idx += 1;\n  });\n  return ix;\n}\n\nexports.toInstruction = toInstruction; // Throws error if any account required for the `ix` is not given.\n\nfunction validateAccounts(ixAccounts) {\n  let accounts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  ixAccounts.forEach(acc => {\n    if (\"accounts\" in acc) {\n      validateAccounts(acc.accounts, accounts[acc.name]);\n    } else {\n      if (accounts[acc.name] === undefined) {\n        throw new Error(`Invalid arguments: ${acc.name} not provided.`);\n      }\n    }\n  });\n}\n\nexports.validateAccounts = validateAccounts; // Translates an address to a Pubkey.\n\nfunction translateAddress(address) {\n  if (typeof address === \"string\") {\n    const pk = new web3_js_1.PublicKey(address);\n    return pk;\n  } else {\n    return address;\n  }\n}\n\nexports.translateAddress = translateAddress;","map":{"version":3,"sources":["../../../src/program/common.ts"],"names":[],"mappings":";;;;;;;AACA,MAAA,SAAA,GAAA,OAAA,CAAA,iBAAA,CAAA;;AASA,SAAgB,cAAhB,CAA+B,GAA/B,EAAuC;AACrC,QAAM,MAAM,GAAG,IAAI,GAAJ,EAAf;;AACA,MAAI,GAAG,CAAC,MAAR,EAAgB;AACd,IAAA,GAAG,CAAC,MAAJ,CAAW,OAAX,CAAoB,CAAD,IAAM;;;AACvB,UAAI,GAAG,GAAG,CAAA,EAAA,GAAA,CAAC,CAAC,GAAF,MAAK,IAAL,IAAK,EAAA,KAAA,KAAA,CAAL,GAAK,EAAL,GAAS,CAAC,CAAC,IAArB;AACA,MAAA,MAAM,CAAC,GAAP,CAAW,CAAC,CAAC,IAAb,EAAmB,GAAnB;AACD,KAHD;AAID;;AACD,SAAO,MAAP;AACD;;AATD,OAAA,CAAA,cAAA,GAAA,cAAA,C,CAWA;;AACA,SAAgB,aAAhB,CACE,KADF,EAEgB;AAAA,oCAAX,IAAW;AAAX,IAAA,IAAW;AAAA;;AAEd,MAAI,KAAK,CAAC,IAAN,CAAW,MAAX,IAAqB,IAAI,CAAC,MAA9B,EAAsC;AACpC,UAAM,IAAI,KAAJ,CAAU,yBAAV,CAAN;AACD;;AACD,QAAM,EAAE,GAA2B,EAAnC;AACA,MAAI,GAAG,GAAG,CAAV;AACA,EAAA,KAAK,CAAC,IAAN,CAAW,OAAX,CAAoB,KAAD,IAAU;AAC3B,IAAA,EAAE,CAAC,KAAK,CAAC,IAAP,CAAF,GAAiB,IAAI,CAAC,GAAD,CAArB;AACA,IAAA,GAAG,IAAI,CAAP;AACD,GAHD;AAKA,SAAO,EAAP;AACD;;AAfD,OAAA,CAAA,aAAA,GAAA,aAAA,C,CAiBA;;AACA,SAAgB,gBAAhB,CACE,UADF,EAEyB;AAAA,MAAvB,QAAuB,uEAAF,EAAE;AAEvB,EAAA,UAAU,CAAC,OAAX,CAAoB,GAAD,IAAQ;AACzB,QAAI,cAAc,GAAlB,EAAuB;AACrB,MAAA,gBAAgB,CAAC,GAAG,CAAC,QAAL,EAAe,QAAQ,CAAC,GAAG,CAAC,IAAL,CAAvB,CAAhB;AACD,KAFD,MAEO;AACL,UAAI,QAAQ,CAAC,GAAG,CAAC,IAAL,CAAR,KAAuB,SAA3B,EAAsC;AACpC,cAAM,IAAI,KAAJ,CAAU,sBAAsB,GAAG,CAAC,IAAI,gBAAxC,CAAN;AACD;AACF;AACF,GARD;AASD;;AAbD,OAAA,CAAA,gBAAA,GAAA,gBAAA,C,CAeA;;AACA,SAAgB,gBAAhB,CAAiC,OAAjC,EAAiD;AAC/C,MAAI,OAAO,OAAP,KAAmB,QAAvB,EAAiC;AAC/B,UAAM,EAAE,GAAG,IAAI,SAAA,CAAA,SAAJ,CAAc,OAAd,CAAX;AACA,WAAO,EAAP;AACD,GAHD,MAGO;AACL,WAAO,OAAP;AACD;AACF;;AAPD,OAAA,CAAA,gBAAA,GAAA,gBAAA","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.translateAddress = exports.validateAccounts = exports.toInstruction = exports.parseIdlErrors = void 0;\nconst web3_js_1 = require(\"@solana/web3.js\");\nfunction parseIdlErrors(idl) {\n    const errors = new Map();\n    if (idl.errors) {\n        idl.errors.forEach((e) => {\n            var _a;\n            let msg = (_a = e.msg) !== null && _a !== void 0 ? _a : e.name;\n            errors.set(e.code, msg);\n        });\n    }\n    return errors;\n}\nexports.parseIdlErrors = parseIdlErrors;\n// Allow either IdLInstruction or IdlStateMethod since the types share fields.\nfunction toInstruction(idlIx, ...args) {\n    if (idlIx.args.length != args.length) {\n        throw new Error(\"Invalid argument length\");\n    }\n    const ix = {};\n    let idx = 0;\n    idlIx.args.forEach((ixArg) => {\n        ix[ixArg.name] = args[idx];\n        idx += 1;\n    });\n    return ix;\n}\nexports.toInstruction = toInstruction;\n// Throws error if any account required for the `ix` is not given.\nfunction validateAccounts(ixAccounts, accounts = {}) {\n    ixAccounts.forEach((acc) => {\n        if (\"accounts\" in acc) {\n            validateAccounts(acc.accounts, accounts[acc.name]);\n        }\n        else {\n            if (accounts[acc.name] === undefined) {\n                throw new Error(`Invalid arguments: ${acc.name} not provided.`);\n            }\n        }\n    });\n}\nexports.validateAccounts = validateAccounts;\n// Translates an address to a Pubkey.\nfunction translateAddress(address) {\n    if (typeof address === \"string\") {\n        const pk = new web3_js_1.PublicKey(address);\n        return pk;\n    }\n    else {\n        return address;\n    }\n}\nexports.translateAddress = translateAddress;\n//# sourceMappingURL=common.js.map"]},"metadata":{},"sourceType":"script"}