{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getMultipleAccounts = exports.invoke = void 0;\n\nconst assert_1 = __importDefault(require(\"assert\"));\n\nconst web3_js_1 = require(\"@solana/web3.js\");\n\nconst common_1 = require(\"../utils/common\");\n\nconst common_2 = require(\"../program/common\");\n\nconst provider_1 = require(\"../provider\");\n/**\n * Sends a transaction to a program with the given accounts and instruction\n * data.\n */\n\n\nasync function invoke(programId, accounts, data, provider) {\n  programId = (0, common_2.translateAddress)(programId);\n\n  if (!provider) {\n    provider = (0, provider_1.getProvider)();\n  }\n\n  const tx = new web3_js_1.Transaction();\n  tx.add(new web3_js_1.TransactionInstruction({\n    programId,\n    keys: accounts !== null && accounts !== void 0 ? accounts : [],\n    data\n  }));\n  return await provider.send(tx);\n}\n\nexports.invoke = invoke;\nconst GET_MULTIPLE_ACCOUNTS_LIMIT = 99;\n\nasync function getMultipleAccounts(connection, publicKeys) {\n  if (publicKeys.length <= GET_MULTIPLE_ACCOUNTS_LIMIT) {\n    return await getMultipleAccountsCore(connection, publicKeys);\n  } else {\n    const batches = (0, common_1.chunks)(publicKeys, GET_MULTIPLE_ACCOUNTS_LIMIT);\n    const results = await Promise.all(batches.map(batch => getMultipleAccountsCore(connection, batch)));\n    return results.flat();\n  }\n}\n\nexports.getMultipleAccounts = getMultipleAccounts;\n\nasync function getMultipleAccountsCore(connection, publicKeys) {\n  const args = [publicKeys.map(k => k.toBase58()), {\n    commitment: \"recent\"\n  }]; // @ts-ignore\n\n  const res = await connection._rpcRequest(\"getMultipleAccounts\", args);\n\n  if (res.error) {\n    throw new Error(\"failed to get info about accounts \" + publicKeys.map(k => k.toBase58()).join(\", \") + \": \" + res.error.message);\n  }\n\n  (0, assert_1.default)(typeof res.result !== \"undefined\");\n  const accounts = [];\n\n  for (const account of res.result.value) {\n    let value = null;\n\n    if (account === null) {\n      accounts.push(null);\n      continue;\n    }\n\n    if (res.result.value) {\n      const {\n        executable,\n        owner,\n        lamports,\n        data\n      } = account;\n      (0, assert_1.default)(data[1] === \"base64\");\n      value = {\n        executable,\n        owner: new web3_js_1.PublicKey(owner),\n        lamports,\n        data: Buffer.from(data[0], \"base64\")\n      };\n    }\n\n    if (value === null) {\n      throw new Error(\"Invalid response\");\n    }\n\n    accounts.push(value);\n  }\n\n  return accounts.map((account, idx) => {\n    if (account === null) {\n      return null;\n    }\n\n    return {\n      publicKey: publicKeys[idx],\n      account\n    };\n  });\n}","map":{"version":3,"sources":["/home/andru/node_modules/@project-serum/anchor/src/utils/rpc.ts"],"names":[],"mappings":"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","sourcesContent":["import assert from \"assert\";\nimport {\n  AccountInfo,\n  AccountMeta,\n  Connection,\n  PublicKey,\n  TransactionSignature,\n  Transaction,\n  TransactionInstruction,\n} from \"@solana/web3.js\";\nimport { chunks } from \"../utils/common\";\nimport { Address, translateAddress } from \"../program/common\";\nimport Provider, { getProvider } from \"../provider\";\n\n/**\n * Sends a transaction to a program with the given accounts and instruction\n * data.\n */\nexport async function invoke(\n  programId: Address,\n  accounts?: Array<AccountMeta>,\n  data?: Buffer,\n  provider?: Provider\n): Promise<TransactionSignature> {\n  programId = translateAddress(programId);\n  if (!provider) {\n    provider = getProvider();\n  }\n\n  const tx = new Transaction();\n  tx.add(\n    new TransactionInstruction({\n      programId,\n      keys: accounts ?? [],\n      data,\n    })\n  );\n\n  return await provider.send(tx);\n}\n\nconst GET_MULTIPLE_ACCOUNTS_LIMIT: number = 99;\n\nexport async function getMultipleAccounts(\n  connection: Connection,\n  publicKeys: PublicKey[]\n): Promise<\n  Array<null | { publicKey: PublicKey; account: AccountInfo<Buffer> }>\n> {\n  if (publicKeys.length <= GET_MULTIPLE_ACCOUNTS_LIMIT) {\n    return await getMultipleAccountsCore(connection, publicKeys);\n  } else {\n    const batches = chunks(publicKeys, GET_MULTIPLE_ACCOUNTS_LIMIT);\n    const results = await Promise.all<\n      Array<null | { publicKey: PublicKey; account: AccountInfo<Buffer> }>\n    >(batches.map((batch) => getMultipleAccountsCore(connection, batch)));\n    return results.flat();\n  }\n}\n\nasync function getMultipleAccountsCore(\n  connection: Connection,\n  publicKeys: PublicKey[]\n): Promise<\n  Array<null | { publicKey: PublicKey; account: AccountInfo<Buffer> }>\n> {\n  const args = [publicKeys.map((k) => k.toBase58()), { commitment: \"recent\" }];\n  // @ts-ignore\n  const res = await connection._rpcRequest(\"getMultipleAccounts\", args);\n  if (res.error) {\n    throw new Error(\n      \"failed to get info about accounts \" +\n        publicKeys.map((k) => k.toBase58()).join(\", \") +\n        \": \" +\n        res.error.message\n    );\n  }\n  assert(typeof res.result !== \"undefined\");\n  const accounts: Array<null | {\n    executable: any;\n    owner: PublicKey;\n    lamports: any;\n    data: Buffer;\n  }> = [];\n  for (const account of res.result.value) {\n    let value: {\n      executable: any;\n      owner: PublicKey;\n      lamports: any;\n      data: Buffer;\n    } | null = null;\n    if (account === null) {\n      accounts.push(null);\n      continue;\n    }\n    if (res.result.value) {\n      const { executable, owner, lamports, data } = account;\n      assert(data[1] === \"base64\");\n      value = {\n        executable,\n        owner: new PublicKey(owner),\n        lamports,\n        data: Buffer.from(data[0], \"base64\"),\n      };\n    }\n    if (value === null) {\n      throw new Error(\"Invalid response\");\n    }\n    accounts.push(value);\n  }\n  return accounts.map((account, idx) => {\n    if (account === null) {\n      return null;\n    }\n    return {\n      publicKey: publicKeys[idx],\n      account,\n    };\n  });\n}\n"]},"metadata":{},"sourceType":"script"}